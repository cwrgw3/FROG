<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>FROG</title>
  <style>
    body {font-family:monospace}
    canvas {display:block; margin:0 auto;}
  </style>
</head>
<body>
  <canvas id="game" width="800" height="360"></canvas>
  <div style="display: flex; margin-top: 3rem;">
    <div id="hud" style="display:block; margin:0 auto;">distance: 0</div>
  </div>

<script>
  const platformSprites = {
    leftTop:  {x:0,  y:16, w:8, h:8}, // 왼쪽 끝(위)
    midTop:   {x:24, y:0,  w:8, h:8}, // 가운데 타일(ㅡ)
    rightTop: {x:16, y:8,  w:8, h:8}, // 오른쪽 끝(위)
    pillarL:  {x:16, y:16, w:8, h:8}, // 왼쪽 기둥 외벽
    pillarR:  {x:24, y:8 , w:8, h:8}, // 오른쪽 기둥 외벽
    pillarInner: {x:24, y:16, w:8, h:8}, // 기둥 내부 채우기용 - 사실 필요없음
  };

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  // const hud = document.getElementById('hud');
  ctx.imageSmoothingEnabled = false;

  const sprite = new Image();
  sprite.src = 'assets/FROG.png';

  const dinoFrames = [
    {x:0,y:0,w:8,h:8},   // 0: 기본
    {x:8,y:0,w:8,h:8},   // 1: 충전
    {x:16,y:0,w:8,h:8},  // 2
    {x:0,y:8,w:8,h:8},   // 3
    {x:8,y:8,w:8,h:8},   // 4
    {x:8,y:0,w:8,h:8},   // 5
  ];

  // 상태 프레임 순서
  const standingFrameIndex = 0; // 기본 상태
  const holdingFrameIndex = 1;  // 충전 상태
  const jumpAnimStart = 2;
  const jumpAnimEnd = 5;
  let landingFrameIndex = 6; //?
if (!dinoFrames[landingFrameIndex]) landingFrameIndex = jumpAnimEnd;

  const scale = 3;
  const platformScale = scale;

  let posX = 0;
  let posY = 0;
  let velX = 0;
  let velY = 0;
  let isJumping = false;
  let isHolding = false;
  let holdStartTime = 0;

  const gravity = 0.7;
  const minSpeed = 9.0;
  const maxSpeed = 17.0;
  const maxChargeMs = 1000;

  const minAngleDeg = 3; // 원래는 5
  const maxAngleDeg = 85;

  let currentFrameIndex = standingFrameIndex;
  let frameTick = 0;
  let jumpFrameSpeed = 8;
  let isLandingShown = false;
  let landingShownAt = 0;
  const landingHoldMs = 160;

  class Platform {
    constructor(x, topY, tiles) {
      this.x = x;
      this.topY = topY;
      this.tiles = Math.max(1, tiles);
      this.width = (platformSprites.leftTop.w + platformSprites.midTop.w * this.tiles + platformSprites.rightTop.w) * platformScale;
      this.hasLeftPillar = 1;
      this.hasRightPillar = 1;
    }

    render(cameraX) {
      const screenX = Math.round(this.x - cameraX);
      const topY = Math.round(this.topY);
      
      // 플랫폼 상단 렌더링
      drawAtlas(platformSprites.leftTop, screenX, topY);
      let midX = screenX + platformSprites.leftTop.w * platformScale;
      for (let i = 0; i < this.tiles; i++) {
        drawAtlas(platformSprites.midTop, midX, topY);
        midX += platformSprites.midTop.w * platformScale;
      }
      drawAtlas(platformSprites.rightTop, midX, topY);

      const pillarW = platformSprites.pillarL.w * platformScale;
      const pillarH = platformSprites.pillarL.h * platformScale;
      
      // 왼쪽 기둥 렌더링 (y=0까지)
      if (this.hasLeftPillar) {
        const leftPillarX = screenX;
        const platformWidth = platformSprites.leftTop.w * platformScale;
        
        let py = topY + platformSprites.leftTop.h * platformScale;
        while (py < canvas.height) {
          // 외벽 (가장 왼쪽)
          drawAtlas(platformSprites.pillarL, leftPillarX, py);
          
          // 내부 채우기 (왼쪽 외벽과 플랫폼 왼쪽 끝 사이)
          for (let ix = leftPillarX + pillarW; ix < leftPillarX + platformWidth; ix += pillarW) {
            if (ix + pillarW <= leftPillarX + platformWidth) {
              drawAtlas(platformSprites.pillarInner, ix, py);
            }
          }
          
          py += pillarH;
        }
      }
      
      // 오른쪽 기둥 렌더링 (y=0까지)
      if (this.hasRightPillar) {
        const rightPillarEndX = screenX + (platformSprites.leftTop.w + platformSprites.midTop.w * this.tiles) * platformScale;
        const rightPillarStartX = rightPillarEndX;
        const platformWidth = platformSprites.rightTop.w * platformScale;
        
        let py = topY + platformSprites.rightTop.h * platformScale;
        while (py < canvas.height) {
          // 외벽 (가장 오른쪽)
          drawAtlas(platformSprites.pillarR, rightPillarStartX, py);
          
          // 내부 채우기 (플랫폼 오른쪽 끝과 오른쪽 외벽 사이)
          for (let ix = rightPillarStartX + pillarW; ix < rightPillarStartX + platformWidth; ix += pillarW) {
            if (ix + pillarW <= rightPillarStartX + platformWidth) {
              drawAtlas(platformSprites.pillarInner, ix, py);
            }
          }
          
          py += pillarH;
        }
      }
    }

  tryLanding(charBoxPrev, charBoxNew) {
    if (!(charBoxPrev.bottom <= this.topY && charBoxNew.bottom >= this.topY)) return false;
    const platLeft = this.x;
    const platRight = this.x + this.width;
    if (charBoxNew.right <= platLeft || charBoxNew.left >= platRight) return false;
    return true;
  }
}

/* -----------------------
  플랫폼 설정 (좁힌 간격)
------------------------*/
const initialPlatformCount = 8;
const minTiles = 0;
const maxTiles = 6;
let minGap = 32;
let maxGap = 108;
const minYoffset = -96;
const maxYoffset = 24;
const baseGroundY = () => {
  const baseY = canvas.height - (dinoFrames[0].h * scale) - 20;
  return Math.floor(baseY / 8) * 8; // 8픽셀 단위로 맞춤
};

let platforms = [];
let cameraX = 0;
const cameraFollowX = 200;
let distance = 0;
let bestDistance = 0;
let gameOver = false;
let gameOverImageLoaded = false;

// 게임 오버 이미지 로딩
const gameOverImage = new Image();
gameOverImage.src = 'assets/FROG.png'; // 같은 스프라이트 시트 사용
gameOverImage.onload = () => {
  gameOverImageLoaded = true;
};

// 게임 오버 버튼 스프라이트 정의 (예시로 기본 프레임 사용, 필요시 다른 좌표로 변경)
const gameOverButton = {
  x:8, y:16, w: 8, h: 8, // 기본 개구리 이미지를 버튼으로 사용
  screenW: 32, screenH: 32 // 화면에서의 크기
};

/* -----------------------
  유틸: 아틀라스에서 조각 그리기
------------------------*/
function drawAtlas(spriteInfo, screenX, screenY) {
  const dw = spriteInfo.w * platformScale;
  const dh = spriteInfo.h * platformScale;
  ctx.drawImage(sprite, spriteInfo.x, spriteInfo.y, spriteInfo.w, spriteInfo.h, screenX, screenY, dw, dh);
}

function getCharBox(x,y) {
  const w = dinoFrames[0].w * scale;
  const h = dinoFrames[0].h * scale;
  return { left: x, top: y, right: x + w, bottom: y + h, width: w, height: h };
}

function randomRange(a,b) { return a + Math.random()*(b-a); }
function randInt(a,b) { return Math.floor(randomRange(a,b+1)); }

function createInitialPlatforms() {
  platforms = [];
  let x = 0;
  const groundTiles = 10;
  const groundYpos = baseGroundY();
  const startPlatform = new Platform(x, groundYpos, groundTiles);
  platforms.push(startPlatform);
  x = startPlatform.x + startPlatform.width + 60;

  for (let i=0;i<initialPlatformCount;i++) {
    const gap = randInt(minGap, maxGap);
    const tiles = randInt(minTiles, maxTiles);
    const yOffset = Math.round(randomRange(minYoffset, maxYoffset) / 8) * 8; // 8픽셀 단위로 맞춤
    const topY = baseGroundY() + yOffset;
    const p = new Platform(x + gap, topY, tiles);
    platforms.push(p);
    x = p.x + p.width;
  }

  // 캐릭터 위치: 시작 플랫폼 위로 확실히 올려놓음
  posX = startPlatform.x + Math.min(40, startPlatform.width/3);
  posY = startPlatform.topY - (dinoFrames[0].h * scale);

  // *** 핵심: 상태 초기화 (초기화 버그 방지) ***
  isHolding = false;
  holdStartTime = 0;
  isJumping = false;
  isLandingShown = false;
  currentFrameIndex = standingFrameIndex;
  frameTick = 0;
  velX = 0;
  velY = 0;
  gameOver = false; // 게임 오버 상태 초기화
}

/* -----------------------
  입력/충전/점프 로직 (참고 코드 기반으로 수정)
------------------------*/
function beginHold() {
  if (gameOver) return; // 게임 오버 시 입력 무시
  if (isJumping || isLandingShown) return;
  if (!isHolding) {
    isHolding = true;
    holdStartTime = performance.now();
  }
}

function releaseHoldAndJump() {
  if (gameOver) return; // 게임 오버 시 입력 무시
  if (!isHolding) return;
  isHolding = false;
  const heldMs = performance.now() - holdStartTime;
  const charge = Math.max(0, Math.min(1, heldMs / maxChargeMs));
  startJump(charge);
}

function startJump(charge) {
  if (gameOver) return; // 게임 오버 시 점프 무시
  if (isJumping) return;
  isJumping = true;
  isLandingShown = false;

  const angleDeg = minAngleDeg + charge * (maxAngleDeg - minAngleDeg);
  const angleRad = angleDeg * Math.PI / 180;
  const speed = minSpeed + charge * (maxSpeed - minSpeed);
  
  velX = Math.cos(angleRad) * speed;
  velY = -Math.sin(angleRad) * speed;

  jumpFrameSpeed = Math.round(4 + 16 * charge);
  if (jumpFrameSpeed < 1) jumpFrameSpeed = 1;

  currentFrameIndex = jumpAnimStart;
  frameTick = 0;
}

// 이벤트 바인딩 (참고 코드와 동일)
// 게임 재시작 함수
function restartGame() {
  distance = 0;
  cameraX = 0;
  gameOver = false;
  createInitialPlatforms();
}

// 게임 오버 버튼 클릭 체크
function checkGameOverButtonClick(mouseX, mouseY) {
  if (!gameOver) return false;
  
  const buttonX = (canvas.width - gameOverButton.screenW) / 2;
  const buttonY = (canvas.height - gameOverButton.screenH) / 2;
  
  return mouseX >= buttonX && mouseX <= buttonX + gameOverButton.screenW &&
         mouseY >= buttonY && mouseY <= buttonY + gameOverButton.screenH;
}

// 키 이벤트
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && gameOver) {
    // 게임 재시작
    restartGame();
    return;
  }
  if (e.code === 'Space' || e.key === ' ') {
    e.preventDefault();
    beginHold();
  }
});
window.addEventListener('keyup', (e) => {
  if (e.code === 'Space' || e.key === ' ') {
    e.preventDefault();
    releaseHoldAndJump();
  }
});

canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  // 게임 오버 상태에서 버튼 클릭 체크
  if (checkGameOverButtonClick(mouseX, mouseY)) {
    restartGame();
    return;
  }
  
  // 일반 게임플레이 입력
  if (e.button === 0) beginHold();
});
document.addEventListener('mouseup', (e) => {
  if (!gameOver) releaseHoldAndJump();
});

canvas.addEventListener('touchstart', (e) => { 
  e.preventDefault(); 
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const touchX = touch.clientX - rect.left;
  const touchY = touch.clientY - rect.top;
  
  // 게임 오버 상태에서 버튼 터치 체크
  if (checkGameOverButtonClick(touchX, touchY)) {
    restartGame();
    return;
  }
  
  // 일반 게임플레이 입력
  beginHold(); 
}, {passive:false});
window.addEventListener('touchend', (e) => { 
  e.preventDefault(); 
  if (!gameOver) releaseHoldAndJump(); 
}, {passive:false});

/* -----------------------
  물리 업데이트 (참고 코드 기반으로 수정)
------------------------*/
function updatePhysics() {
  if (gameOver) return; // 게임 오버 시 물리 업데이트 중지
  
  if (isJumping) {
    // 중력 적용
    velY += gravity;
    posY += velY;
    posX += velX;

    // 바닥에 닿으면 게임 오버
    if (posY >= canvas.height - (dinoFrames[0].h * scale)) {
      gameOver = true;
      isJumping = false;
      velX = 0;
      velY = 0;
      return;
    }

    // 충돌 감지 (하강 중일 때만)
    if (velY >= 0) {
      const prevBox = getCharBox(posX - velX, posY - velY);
      const newBox = getCharBox(posX, posY);

      for (let i = 0; i < platforms.length; i++) {
        const p = platforms[i];
        if (p.tryLanding(prevBox, newBox)) {
          posY = p.topY - newBox.height;
          velY = 0;
          isJumping = false;

          // 착지 프레임 표시
          currentFrameIndex = landingFrameIndex;
          isLandingShown = true;
          landingShownAt = performance.now();
          velX = 0;
          break;
        }
      }
    }
  } else {
    // 지면에 있을 때는 플랫폼 위치 유지
    const charCenterX = posX + getCharBox(posX, posY).width / 2;
    let standPlat = null;
    for (let p of platforms) {
      if (charCenterX >= p.x && charCenterX <= p.x + p.width) {
        standPlat = p;
        break;
      }
    }
    if (standPlat) {
      posY = standPlat.topY - getCharBox(posX, posY).height;
    }
  }

  // 카메라 업데이트
  if (posX - cameraX > cameraFollowX) cameraX = posX - cameraFollowX;
  if (cameraX < 0) cameraX = 0;

  // 플랫폼 관리
  while (platforms.length && platforms[0].x + platforms[0].width < cameraX - 200) platforms.shift();

  let lastPlatRight = 0;
  if (platforms.length) {
    const last = platforms[platforms.length - 1];
    lastPlatRight = last.x + last.width;
  }
  while (lastPlatRight < cameraX + canvas.width * 2) {
    const newP = spawnPlatformAfter(lastPlatRight);
    lastPlatRight = newP.x + newP.width;
  }

  distance = Math.max(distance, Math.floor(posX));
  if (distance > bestDistance) bestDistance = distance;
  
  const status = gameOver ? " [GAME OVER - Press R to restart]" : "";
  hud.innerText = `distance: ${distance}  best: ${bestDistance}${status}`;
}

/* -----------------------
  애니메이션/렌더 (참고 코드 기반으로 수정)
------------------------*/
function updateAnimation() {
  if (isHolding && !isJumping && !isLandingShown) {
    currentFrameIndex = holdingFrameIndex;
  } else if (isJumping) {
    frameTick++;
    if (frameTick >= jumpFrameSpeed) {
      frameTick = 0;
      currentFrameIndex++;
      if (currentFrameIndex > jumpAnimEnd) {
        currentFrameIndex = jumpAnimEnd;
      }
    }
  } else if (isLandingShown) {
    const now = performance.now();
    if (now - landingShownAt >= landingHoldMs) {
      isLandingShown = false;
      currentFrameIndex = standingFrameIndex;
    } else {
      currentFrameIndex = landingFrameIndex;
    }
  } else {
    currentFrameIndex = standingFrameIndex;
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (const p of platforms) p.render(cameraX);

  const screenX = Math.round(posX - cameraX);
  const screenY = Math.round(posY);
  const frame = dinoFrames[currentFrameIndex];
  const dw = frame.w * scale;
  const dh = frame.h * scale;
  const flip = (velX < 0) ? false : true;
  
  if (flip) {
    ctx.save();
    ctx.scale(-1, 1);
    ctx.drawImage(sprite, frame.x, frame.y, frame.w, frame.h, -(screenX + dw), screenY, dw, dh);
    ctx.restore();
  } else {
    ctx.drawImage(sprite, frame.x, frame.y, frame.w, frame.h, screenX, screenY, dw, dh);
  }

  
  // --- 여기에 충전량 표시 추가 ---
  if (isHolding) {
    // 0..1 사이의 현재 충전량 계산
    const heldMs = Math.max(0, performance.now() - holdStartTime);
    const charge = Math.max(0, Math.min(1, heldMs / maxChargeMs));

    // 바 크기 및 위치 (디자인은 나중에 변경 가능)
    const barWidth = 24;   // 바 전체 너비 (픽셀)
    const barHeight = 3;   // 바 높이
    const barX = screenX + Math.round((dw - barWidth) / 2);
    const barY = screenY - 4; // 개구리 바로 위

    ctx.save();

    ctx.fillStyle = 'black';
    ctx.fillRect(barX-3, barY-3, barWidth+6, barHeight+6);

    ctx.fillStyle = 'lime';
    ctx.fillRect(barX, barY, Math.round(barWidth * charge), barHeight);

    ctx.restore();
  }
  // --- 충전량 표시 끝 ---
  // 게임 오버 UI 렌더링
  if (gameOver && gameOverImageLoaded) {

    // 재시작 버튼 (이미지)
    const buttonX = (canvas.width - gameOverButton.screenW) / 2;
    const buttonY = (canvas.height - gameOverButton.screenH) / 2;
    
    // 버튼 이미지 (개구리)
    ctx.drawImage(gameOverImage, 
      gameOverButton.x, gameOverButton.y, gameOverButton.w, gameOverButton.h,
      buttonX, buttonY, gameOverButton.screenW, gameOverButton.screenH);
    
  }
}

/* -----------------------
  플랫폼 스폰 헬퍼
------------------------*/
function spawnPlatformAfter(lastX) {
  const gap = randInt(minGap, maxGap);
  const tiles = randInt(minTiles, maxTiles);
  const yOffset = Math.round(randomRange(minYoffset, maxYoffset) / 8) * 8; // 8픽셀 단위로 맞춤
  const topY = baseGroundY() + yOffset;
  const p = new Platform(lastX + gap, topY, tiles);
  platforms.push(p);
  return p;
}

/* -----------------------
  루프 초기화 / 시작
------------------------*/
function loop() {
  updatePhysics();
  updateAnimation();
  render();
  requestAnimationFrame(loop);
}

sprite.onload = () => {
  createInitialPlatforms();
  loop();
};

</script>
</body>
</html>


