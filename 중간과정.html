<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>angle-charged-jump-5to85</title>
  <style>
    body { margin:0; background:gold; }
    canvas { display:block; margin:0 auto; image-rendering: pixelated; image-rendering: crisp-edges; }
  </style>
</head>
<body>
  <canvas id="game" width="500" height="300"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false; // 픽셀 아트 보존

    const sprite = new Image();
    sprite.src = 'assets/FROG.png';

    // 프레임 정의 (0..N-1)
    const dinoFrames = [
      {x:0,y:0,w:8,h:8},   // 0: 기본
      {x:8,y:0,w:8,h:8},  // 1: 충전
      {x:16,y:0,w:8,h:8},  // 2
      {x:0,y:8,w:8,h:8},  // 3
      {x:8,y:8,w:8,h:8}, // 4
      {x:8,y:0,w:8,h:8}, // 5
    ];

    // 인덱스 상수
    const standingFrameIndex = 0;
    const holdingFrameIndex = 1;
    const jumpAnimStart = 2;
    const jumpAnimEnd = 5;
    let landingFrameIndex = 6;
    if (!dinoFrames[landingFrameIndex]) landingFrameIndex = jumpAnimEnd;

    // 스케일/위치
    const scale = 4;          // 정수 배율 권장 (원하면 변경)
    let posX = 100;           // 초기 수평 위치
    let canvasWidth = canvas.width;
    let canvasHeight = canvas.height;
    const groundOffset = 20;  // 바닥 여백

    // 물리/점프 파라미터
    const gravity = 0.7;         // 중력(프레임 단위)
    const minSpeed = 9.0;        // 최소 속력 (pixel/frame)
    const maxSpeed = 17.0;       // 최대 속력
    const maxChargeMs = 1200;    // 최대 충전 시간(밀리초)

    // 애니메이션 속도 파라미터 (ticks per frame)
    const frameSpeedMin = 4;   // 빠를 때
    const frameSpeedMax = 20;  // 느릴 때

    // 착지 프레임 표시 시간 (ms)
    const landingHoldMs = 160;

    // 각도 범위: 최소 5도, 최대 85도
    const minAngleDeg = 0;
    const maxAngleDeg = 88;

    // 상태 변수
    let posY = 0;
    let groundY = 0;
    let velX = 0;
    let velY = 0;
    let isJumping = false;

    let isHolding = false;
    let holdStartTime = 0;

    let currentFrameIndex = standingFrameIndex;
    let frameTick = 0;
    let jumpFrameSpeed = Math.round((frameSpeedMin + frameSpeedMax) / 2);

    let isLandingShown = false;
    let landingShownAt = 0;

    // 표시용: 현재 각도/충전량 (디버그)
    let lastAngleDeg = 0;
    let lastCharge = 0;

    sprite.onload = () => {
      // groundY 계산
      groundY = canvas.height - (dinoFrames[0].h * scale) - groundOffset;
      posY = groundY;
      loop();
    };

    // drawFrame: flip 기본 true -> 오른쪽 바라보게
    function drawFrame(frame, dx, dy, flip = true) {
      ctx.imageSmoothingEnabled = false;
      const dw = frame.w * scale;
      const dh = frame.h * scale;
      if (flip) {
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(sprite, frame.x, frame.y, frame.w, frame.h, -(dx + dw), dy, dw, dh);
        ctx.restore();
      } else {
        ctx.drawImage(sprite, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);
      }
    }

    // 입력 시작 (hold)
    function beginHold() {
      if (isJumping || isLandingShown) return;
      if (!isHolding) {
        isHolding = true;
        holdStartTime = performance.now();
      }
    }

    // 입력 해제 -> 점프 시작 (charge 0..1)
    function releaseHoldAndJump() {
      if (!isHolding) return;
      isHolding = false;
      const heldMs = performance.now() - holdStartTime;
      const charge = Math.max(0, Math.min(1, heldMs / maxChargeMs));
      lastCharge = charge;
      startJump(charge);
    }

    // startJump: charge에 따라 angle과 speed 설정
    function startJump(charge) {
      if (isJumping) return;
      isJumping = true;
      isLandingShown = false;

      // 각도: minAngleDeg .. maxAngleDeg (예: 5..85)
      const angleDeg = minAngleDeg + charge * (maxAngleDeg - minAngleDeg);
      lastAngleDeg = angleDeg;
      const angleRad = angleDeg * Math.PI / 180;

      // 속력(크기): 선형 보간
      const speed = minSpeed + charge * (maxSpeed - minSpeed);

      // 속도 성분
      velX = Math.cos(angleRad) * speed;      // 오른쪽으로
      velY = -Math.sin(angleRad) * speed;     // 위로 (음수)

      // 애니메이션 속도(충전량 클수록 느려짐)
      jumpFrameSpeed = Math.round(frameSpeedMin + (frameSpeedMax - frameSpeedMin) * charge);
      if (jumpFrameSpeed < 1) jumpFrameSpeed = 1;

      // 애니메이션 초기화: 점프 애니 시작 인덱스로
      currentFrameIndex = jumpAnimStart;
      frameTick = 0;
    }

    // 이벤트 바인딩
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.key === ' ') {
        e.preventDefault();
        beginHold();
      }
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space' || e.key === ' ') {
        e.preventDefault();
        releaseHoldAndJump();
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 0) beginHold();
    });
    document.addEventListener('mouseup', (e) => {
      releaseHoldAndJump();
    });

    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); beginHold(); }, {passive:false});
    window.addEventListener('touchend', (e) => { e.preventDefault(); releaseHoldAndJump(); }, {passive:false});

    // 물리 업데이트 (프레임 단위)
    function updatePhysics() {
      if (isJumping) {
        // 중력 적용
        velY += gravity;
        posY += velY;
        posX += velX;

        // 착지 감지
        if (posY >= groundY) {
          posY = groundY;
          velY = 0;
          isJumping = false;

          // 착지 시 착지 프레임 표시
          currentFrameIndex = landingFrameIndex;
          isLandingShown = true;
          landingShownAt = performance.now();

          // 착지하면 수평속도 0으로 정지
          velX = 0;
        }
      } else {
        // 지면에 있을 때는 y 고정
        posY = groundY;
      }

      // 화면 경계 처리 (간단 순환)
      if (posX > canvas.width + 50) posX = -50;
      if (posX < -50) posX = canvas.width + 50;
    }

    // 애니메이션 업데이트
    function updateAnimation() {
      if (isHolding && !isJumping && !isLandingShown) {
        currentFrameIndex = holdingFrameIndex;
      } else if (isJumping) {
        frameTick++;
        if (frameTick >= jumpFrameSpeed) {
          frameTick = 0;
          currentFrameIndex++;
          if (currentFrameIndex > jumpAnimEnd) {
            currentFrameIndex = jumpAnimEnd; // 멈춤 (착지는 물리에서 처리)
          }
        }
      } else if (isLandingShown) {
        const now = performance.now();
        if (now - landingShownAt >= landingHoldMs) {
          isLandingShown = false;
          currentFrameIndex = standingFrameIndex;
        } else {
          currentFrameIndex = landingFrameIndex;
        }
      } else {
        currentFrameIndex = standingFrameIndex;
      }
    }

    // 렌더링 (디버그 텍스트 포함)
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 땅 표시 (간단)
      ctx.fillStyle = '#6b3';
      const groundH = 4;
      ctx.fillRect(0, groundY + (dinoFrames[0].h * scale), canvas.width, groundH);

      // 캐릭터 그리기, flip: velX < 0 -> 왼쪽, velX >=0 -> 오른쪽
      const flip = (velX < 0) ? false : true;
      drawFrame(dinoFrames[currentFrameIndex], Math.round(posX), Math.round(posY), flip);

      // 디버그: 각도/충전량/속도 표시 (원하면 지울 것)
      ctx.fillStyle = 'black';
      ctx.font = '12px monospace';
      ctx.fillText(`charge: ${Math.round(lastCharge*100)}%`, 8, 16);
      ctx.fillText(`angle: ${Math.round(lastAngleDeg)}°`, 8, 32);
      ctx.fillText(`velX: ${velX.toFixed(2)}`, 8, 48);
      ctx.fillText(`velY: ${velY.toFixed(2)}`, 8, 64);
    }

    // 메인 루프
    function loop() {
      updatePhysics();
      updateAnimation();
      render();
      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
